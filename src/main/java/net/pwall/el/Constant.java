/*
 * @(#) Constant.java
 *
 * JSTL Expression Language Parser / Evaluator
 * Copyright (C) 2003, 2005, 2006, 2007, 2012, 2013, 2020  Peter Wall
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.pwall.el;

/**
 * A class to represent a constant in an expression tree.  Objects of this class are created
 * for constants in the expression.  The {@link #optimize()} method will pre-evaluate
 * operators with constant operands where possible.
 *
 * @author  Peter Wall
 */
public class Constant extends Expression {

    public static final String nullString = "";
    public static final Constant trueConstant = new Constant(Boolean.TRUE);
    public static final Constant falseConstant = new Constant(Boolean.FALSE);
    public static final Constant nullStringConstant = new Constant(nullString);

    private final Object value;

    /**
     * Construct a {@code Constant} with a given object value.
     *
     * @param value  the object
     */
    public Constant(Object value) {
        this.value = value;
    }

    /**
     * Get the value represented by the constant.
     *
     * @return  the value represented by the constant
     */
    public Object getValue() {
        return value;
    }

    /**
     * Evaluate the subexpression.
     *
     * @return  the value represented by the constant
     */
    @Override
    public Object evaluate() {
        return value;
    }

    /**
     * Return {@code true} to indicate the expression is constant.
     *
     * @return {@code true} - the expression is constant
     */
    @Override
    public boolean isConstant() {
        return true;
    }

    /**
     * Get the result type of this constant.
     *
     * @return  the result type of the constant
     */
    @Override
    public Class<?> getType() {
        return value == null ? null : value.getClass();
    }

    /**
     * Test for equality.  Return {@code true} only if the other object is a constant with
     * the same value.
     *
     * @param o  the object for comparison
     * @return   {@code true} if expressions are equal
     * @see Object#equals(Object)
     */
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Constant))
            return false;
        Constant c = (Constant)o;
        if (value == null)
            return c.value == null;
        return value.equals(c.value);
    }

    /**
     * Ensure that objects which compare as equal return the same hash code.
     *
     * @return the hash code
     * @see Object#hashCode()
     */
    @Override
    public int hashCode() {
        return value == null ? 0 : value.hashCode();
    }

    /**
     * Convert to string.  This returns the string representation of the constant in the
     * Expression Language.  String constants require special handling to ensure that quotes
     * are used and special characters are escaped.
     *
     * @return  a string representation of the constant
     */
    @Override
    public String toString() {
        if (value == null)
            return "null";
        if (value instanceof String) {
            StringBuilder sb = new StringBuilder();
            String str = (String)value;
            char quote = str.indexOf('\'') >= 0 && str.indexOf('"') < 0 ? '"' : '\'';
            sb.append(quote);
            for (int i = 0, n = str.length(); i < n; ++i) {
                char ch = str.charAt(i);
                if (ch == quote || ch == '\\')
                    sb.append('\\');
                sb.append(ch);
            }
            sb.append(quote);
            return sb.toString();
        }
        // note - for all other forms of constant generated by the parser, the standard
        // toString() conversion on the object will produce the correct form of string; any
        // constants generated by a Resolver must provide their own formatting, probably by
        // subclassing Constant
        return value.toString();
    }

}
